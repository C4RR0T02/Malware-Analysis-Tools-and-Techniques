# Assembly Part 1

## Why Assembly Language?

- Malware can be found in portable executable files
- Basic static and dynamic malware analysis methods do not provide enough information to analyze malware completely
- Analysing malware codes in Assembly language provides more complete information

## What is Assembly Language?

- Machine Language is interpreted on a computer architecture
- Representation of machine language
- Obtained from disassembly of binary code

## What are levels of abstration

![](levels%20of%20abstraction.png)  

- levels of abstraction that create a way of hiding the implementation details
- levels start from the bottom
- Higher level of abstractio placed near the top with more specific concepts.
- Lower levels result in less portable the level accross computer systems

## x86 Architecture

![](x86%20Architecture.png)  

Van Neumann Architecture Consists of 3 hardware components

- `Central Processing Unit (CPU)` executes code
- `Main memory` stores all data and code
- `Input / Output system (I/O)` interface with devices such as hard drives, keyboards and monitors

1. `CPU` gets instructions to execute from RAM using a `register` (`Instruction Pointer`)

        Instruction Pointer stores address of the next instruction to execute

2. `Register` stores the address of the instructions to execute

        Registers are the CPU’s basic data storage units and are often used to save time so that the CPU doesn’t need to access RAM.

3. `Arithmatic Logic Unit (ALU)` executes the instructions fetched from the RAM and places result in registers / memory
4. Process of fetching and executing instruction after instruction is repeated when the program runs

### Main Memory

![](Main%20Memory.png)  

- Can be divided into 4 major sections
- Order of the sections may not be the same

1. Data Section

    - Refer to specific section of memory
    - Contain values put in place when the program is initially loaded
    - Sometimes called Static values - Do not change when program is running / Global values

2. Code

    - Includes instructions fetched by CPU to execute program task
    - Control what the program does and how the program tasks are orchestrated

3. Heap

    - Used for dynamic memory during program execution
        - create (allocate) values
        - eliminate (free) values 
    - refered as dynamic memory
        - contents can change frequently when program is running

4. Stack

    - Used for local variables and parameters for functions
    - Help control Program flow

### Instructions

#### Instruction Format

`mnemonic` and zero or more `operands`

    MNEMONIC word that identifies the instructions to execute
    Example: mov

    OPERANDS used to identify information used by the instruction
    Example: registers or data

![](Instruction%20Format.png)  

#### Opcodes and Endianness

- Each instruction correspond to `opcodes (Operation Codes)`
- Tell CPU the operation the program wants to perform
- Disassembler tranlate opcodes into human-readable instruction

![](Instruction%20Opcodes.png)  

`0x42000000` is treated as `0x42` as the architecture uses `little endian format`

Endianness of data describe wheter the most significant bit (`big-endian`) or least significant bit (`little-endian`) byte is ordered first (at the smallest address) within a larger data item

Require conversion when malware makes use of network communications

#### Operands

- Used to identify data used by the instruction
- Has 3 ways it can be used in
    1. `Immediate` operands are fixed value
    2. `Register` operands refer to registers like ECX
    3. `Memory Address` operands refer to memory address that contains the value of interest
        - Denoted by a value, register, or equation between brackets
        - Such as [eax].
- Opcode is a machine language equivalent of an executed assembly instruction
- Identifiers are not case-sensitive

### Registers

- Small amount of data storage available to CPU
- Content can be accessed more quickly than storage available
- x86 processors have collection of register for use as temporary storage
- 4 register categories
    - `General registers` are used by CPU during execution
    - `Segment registers` are used to track sections of memory
    - `Status registers` are used to make decisions
    - `Instruction Pointers` are used to keep track of the next instruction to execute

![](x86%20Registers.png)  

#### Register size

![](Register%20Size.png)  

### General Registers

- Typically store data or memory address
- Used interchangably to get things done within the program
- Some instructions use specific registers by defintion
    - Division use EDX
    - Multiplication use EAX
    - EAX can also hold return value for function call
    - ESP, EBP used for function call/return
    - ESI, EDI and ECX are used in repeat instructions
        - ESI and EDI may store memory address

- General registers can be used in a consistant fashion throughout a program
- Use of registers in a consistent fashion across compiled code is known as a `convention`
- Allows the quicker examination of code (from convention)

### Flags

- EFLAGS Register is a status register
- 32 bits in size, each bit is a flag
- Flags are set to `1` or `0`
- Control CPU operations / Indicate results of CPU operation

#### Important Flags

|Flag|Name of Flag|Description|
|:--:|:--|:--|
|ZF|Zero Flag|Set when result of operation is equal to zero|
|CF|Carry Flag|Set when result of an operation is too large or too small for destimation operand|
|SF|Sign Flag|Set when result of operation is negative, cleared when result is positive / set when the most significant bit is set after an arithmetic operation.|
|TF|Trap Flag|Used for debugging. Execute one instruction at a time when flag is set|
|OF|Overflow Flag|Set when an instruction generates an invalid signed result|

### EIP (Instruction Pointer / Program Counter)

- Register that contains the memory address of the next instruction to be executed for a program
- Purpose is to tell the processor what to do next
- When EIP is corrupted, program will likely crash

### Data Allocation

|Syntax|Name|Size|
|--|--|--|
|DB|Define Byte|1 byte|
|DW|Define Word|2 byte|
|DD|Define DoubleWord|4 byte|
|DQ|Define QuadWord|8 byte|
|DT|Define Ten Byte|10 byte|
|?|Uninitialized data|-|
|;|Comment|-|
|''|Strings|multiple bytes|

- Strings allocate multiple bytes
- Labels in front of the directives remember offsets from the beginning of the segment accomodating the directive
- Multiple definitions can be abbreviated
- Multiple definition can be initialised in data structures like arrays

### Data Allocation Directives

|Syntax|Purpose|Example|
|--|--|--|
|DUP|Used to initialise duplicated value|DB 10 DUP(?)|
|EQU|Assign result of expression to name, expression is evaluated at assembly time|-|

### C Data Types

|Directive|C data type|
|--|--|
|DB|char|
|DW|int, unsigned int|
|DD|float, long|
|DQ|double|
|DT|internal intermediate float value|

![](Data%20Type%20and%20Description.png)  

### Program Layout

![](Program%20Layout.png)  

### Assembly Instructions

- mov (move)
- lea (load effective address)
- [] (memory address)
- sub (subtract)
- add (add)
- inc (increment)
- dec (decrement)
- mul (multiply)
- div (divide)

|Instruction|Description|
|--|--|
|mov eax, ebx|Copies te contents of EBX into the EAX register|
|mov eax, 0x42|Copies the value of 0x42 into the EAX register|
|mov eax, [0x4037C4]|Copies the 4 bytes of te memory location 0x4037C4 into the EAX register|
|mov eax, [ebx]|Copies the 4 bytes at the memory location specified by the EBX register into the EAX register|
|mov eax, [ebx+esi*4]|Copies the 4 bytes at the memory location specified by the result of the equation ebx+esi*4 into the EAX register|
|movsx eax, bh|(move with sign extend) move the higher byte of the 16-bit register BX sign-extended into the 32-bit register EAX|
|lea ax, [bx]|Puts value in bx into ax|
|lea bx, [bx+3]|Increases value in bx by 3|
|lea eax, [ebx+8]|Puts value of (ebx + 8) into eax|
|lea ecx, [0+4*eax+eax]|Multiplies value in eax by 5 and puts it into ecx|
|lea esi, [ebx+8*eax+4]|Puts value of (ebx + 8*eax + 4) into esi|
|sub eax, 0x10|Subtracts 0x10 from EAX|
|add eax, ebx|Adds EBX to EAX and stores the result in EAX|
|inc edx|Increment EDX by 1|
|dec ecx|Increment ECX by 1|
|mul value|multiply eax by a value and the result is stored in edx:eax|
|div value|divide edx:eax by value and the result in eax and remainder in edx|

#### Logical Operators

- OR
- AND
- XOR
    - Used to set the register to zero
    - XOR EAX, EAX
- SHR
    - Shift right the registers by the count
    - SHR destination, count
    - CF flag contains the last bit shifted out of the destination
- SHL
    - Shift left the registers by the count
    - SHL destination, count
    - CF flag contains the last bit shifted out of the destination
operand
- ROR
    - Shift right the registers by the count
    - bits shifted move to the front of the register
- ROL
    - Shift left the registers by the count
    - bits shifted move to the end of the register

|Instruction|Description|
|--|--|
|xor eax, eax|Clears the EAX register|
|or eax, 0x7575|Performs the logical or operation on EAX with 0x7575|
|mov eax, 0xA|Shifts the EAX register to the left 2 bits; result in EAX = 0x28, because 1010 (0xA in binary) shifted 2 bits left is 101000 (0x28)|
|shl eax, 2|Shifts the EAX register to the left 2 bits; result in EAX = 0x28, because 1010 (0xA in binary) shifted 2 bits left is 101000 (0x28)|
|mov bl, 0xA|Rotates the BL register to the right 2 bits; result in BL = 10000010, because 1010 rotated 2 bits right is 10000010|
|ror bl, 2|Rotates the BL register to the right 2 bits; result in BL = 10000010, because 1010 rotated 2 bits right is 10000010|

### NOP

- No Operation
- Proceed to the next instruction
- Used for buffer overflow attacks

### INT

- Interrupt 
- INT 21H calls DOS Interrupt Service Routine

## Reference Materials
|Reference Material|Page Number|
|--|--|
|[Practical Maware Analysis Book](/Practical%20Malware%20Analysis.pdf)|Page 98 - 118|
