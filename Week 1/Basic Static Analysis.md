# Basic Static Analysis

## Malware Fingerprint

1. Scan the file with an Antivirus scanner (VirusTotal)

    AntiVirus Scanner uses 
    - File Signatures
        - Identifiable pieces of suspicious code
    - Heuristics
        - Behavious and pattern-matching analysis
    
    Flaws in Antivirus
    - Malicious file identified by an Antivirus may not be identified by another Antivirus
    - Scans suspicious files using different Antivirus engines
    - Generates report and provide total number of Antivirus that flags the suspicious files
    - Acquired by google

2. Hashing (WinMD5)

    - Common way to fingerprint malware
    - Generated by a hashing alogorithm
    - One way function
        - cannot be recovered

## Finding Strings in Malware

3. Strings (BinText)

    - Sequence of characters terminated with a NULL (0x00) character
    - can reveal information on the program
        - URLs
        - Filenames
        - Windows Function Calls

    Types of Strings
    - ASCII
        - 1 byte per character
        - represented in hexadecimal format
    - Unicode
        - 2 bytes per character

## Portable Executable (PE) (Dependency Walker)

- PE File Format used by Windows executables, object code, DLLs
- PE File Format is a data structure that contains necessary information for Windows OS Loader to execute compiled codes
- Begin with header that includes information like
    - Coder
    - Type of application
    - Required libraries
    - Space requirements

![](PE%20Lifecycle.png)  

Programmer writes a `source file`. The `source file` gets translated into an `object module`. The linker than combines the various object modules into an `executable image`.

Once the `executable image` is loaded, it will execute the image on the system.

    An executable file is a complete program that can be run directly by an operating system (in conjunction with shared libraries and system calls). The file generally contains a table of contents, a number of code blocks and data blocks, ancillary data such as the memory addresses at which different blocks should be loaded, which shared libraries are needed, the entry point address, and sometimes a symbol table for debugging. An operating system can run an executable file more or less by loading blocks of code and data into memory at the indicated addresses and jumping to it.

    Most programs are written with source code logically divided into multiple source files. Each source file is compiled independently into a corresponding "object" file of partially-formed machine code known as object code. At a later time these "object files" are "linked" together to form an executable file.

    Object files have a lot in common with executable files (table of contents, blocks of machine instructions and data, and debugging information). However, the code isn't ready to run. It is full of incomplete references to subroutines outside itself, and as such, many of the machine instructions have only placeholder addresses.
    The linker, as a final phase of compilation, will read all of the object files, resolve references between them, perform the final code layout in memory that determines the addresses for all the blocks of code and data, fix up all the placeholder addresses with real addresses, and write out the executable file.

### Loading a Portable Executable (PE) 

#### Types of loading

1. Absolute Loading
        - Load program at same address everytime
2. Relocatable Loading
        - Load program at different address based on what is available
3. Dynamic Run-time loading
        - Load and reload program at different address while program is running.

#### Address Binding

- Must be brought to main memory before execution
- istructions that use addresses must be properly bounded to address space in memory
- Scheme that perform the job
- Symbolic name / label bounded to the actual address
- actual binding can be specified / resolved at
    - Compile time
    - Link time
    - Load time
    - Run time

#### Types of linking

1. Static Linking

    - Statistically linked to a binary
    - All executable code from library is copied into the executable
    - Difficult to differentiate the code between statistically linked and executables code
    - PE header does not contain such information

2. Dynamic Linking

    - Executable connect to library only when function is needed
    - Executable search and load correct library at runtime
    - address of library function to connect resolved at runtime
    - Information to resolve address stored in .idata (import section)

#### PE File Format

![](PE%20FIle%20Format.png)  

#### Relative Virtual Address

- Virtual Address that is relative to the base address of the executable program

    A base address is a unique location in primary storage (or main memory) that serves as a reference point for other memory locations called absolute addresses.

    In order to obtain an absolute address, a specific displacement (or offset) value is added to the base address. In primary storage, all addresses literally comprise fixed-length sequences of bits that stand for positive whole numbers usually expressed in hexadecimal form. For example, a base address might indicate the beginning of a program loaded into primary storage. The absolute address of each individual program instruction could be specified by adding a displacement to the base address.

- Address may not be known at link time
- Addresses stored in code by linker must be relative

#### Base Address, Relative Address

`Base Address` that serves as a reference point for other address.
`Relative Address` of an instruction is the offset from the `Base Address`

### PE File Format

- Starts with DOS Header
    - Signature "MZ" (4D 5A, Mark Zbikowski - Developer of MS-DOS)
    - Offset to PE Header
- PE Header
    - Machine Type
    - Number of Sections
    - Timestamp
    - Data Directory (Where the data is stored)
- Section Table
    - List of Sections
- Sections

### PE Sections

|Field|Purpose|
|:----:|:----:|
|.text|Executable Code|
|.data|Read / Write initialised data|
|.rdata|Read only data|

- Note that the linker combines text and data from various object modules to form the executable image.  
- Compilers can append “$…” to the end of the names to dictate the ordering within a section.  
- For example “.text$X” is before “.text$Y” in the .text section

#### .edata (Exports)

- Run image required by calling the dll
- Loader must be able to find entry points into the dll
- Export table stores the list of addresses that the dll can call
- Exported entry point has a unique ordinal value
- entry point requires to know dll name and ordinal number
- Programmers are unsure of ordinal number
- export table used to translate names to ordinal numbers

#### Base Relocation

- addresses must be fixed when module is relocated
- .reloc specifies location of where the module is moved to

#### .resrc

- Resources for images
- Examples: Bitmaps and icons
- Organised like file systems

#### .debug

- Debug information
- Was “coff” up to NT 4.0 and has moved onto “pdb” in Window XP

## Packed Executables

- Obfuscated to make it hard to analyse
- Aim to hide malware functionality
- Obfuscation through
    - Compression
    - Encryption
- EXE is not readable when encrypted

![](Packed%20Malware.png)  

    Small wrapper stub to decompress / decrypt original before loading to memory
    Only stub is analysable when program is packed

### Detecting Packers

- PEiD
- Has inbuild packers like
    - UPX
    - ASPack
    - PELock
    - Themida