# Assembly Part 2

## Conditionals

- instructions that perform comparison
- comparison results alter status flags
- Decision based on value of status flag
- Specific bits (flags) in the status register (EFLAGS) can be set or cleared
- Program executio depends on comparison results
- conditional instructions
    - `TEST`
        - Identical to the `AND`
        - Does not modify the instructions
        - Set flags (usually zero flag)
    - `CMP`
        - Identical to the `SUB`
        - Operands are not affected
        - Set flags (usually zero flag and carry flag)

![](Conditionals%20Set%20Flags.png)  

### AND

Perform boolean AND operation between each pair of matching bits in two operands

    AND Destination, Source

![](AND%20Operation.png)  

### OR

Perform boolean OR operation between each pair of matching bits in two operands

    OR Destination, Source

![](OR%20Operation.png) 

### XOR

Perform boolean exclusive-OR operation between each pair of matching bits in two operands

Useful in inverting bits in an operand

    XOR Destination, Source

![](XOR%20Operation.png)  

### NOT

Perform boolean NOT operation on a single destination operand

    NOT Destination

![](NOT%20Operation.png)  

### TEST

- Performs a nondestructive AND operation between each pair of matching bits in two operands
- No operands are modified, but the Zero flag is affected

![](TEST%20Jump.png)  

### CMP

- Compares the destination operand to the source operand
    - Nondestructive subtraction of source from destination (destination operand is not changed)
- CMP Destination, Source

![](CMP%20Setting%20Individual%20Flags.png)  

![](CMP%20Cleared%20Flags.png)  

#### Comparison with Signed integers

![](CMP%20Signed%20Integer%20Flags.png)  

## Conditional Jumps

- Jumps based on 
    - Specific Flags
    - Equality
    - Unsigned Comparisons
    - Signed Comparisons
- Conditional jump instruction branches to a label when specific register or flag conditions are met

### Jump based on Specific Flags

|Mnemonic|Description|Flags|
|--|--|--|
|JZ|Jump if zero|ZF=1|
|JNZ|Jump if not zero|ZF=0|
|JC|Jump if carry|CF=1|
|JNC|Jump if not carry|CF=0|
|JO|Jump if overflow|OF=1|
|JNO|Jump if not overflow|OF=0|
|JS|Jump if signed|SF=1|
|JNS|Jump if not signed|SF=0|
|JP|Jump if parity (even)|PF=1|
|JNP|Jump if not parity (odd)|PF=0|

### Jump based on Equality

|Mnemonic|Description|
|--|--|
|JE|Jump if equal|
|JNE|Jump if not equal|
|JCXZ|Jump if CX=0|
|JECXZ|Jump if ECX=0|

### Jump based on Unsigned Comparisons

|Mnemonic|Description|
|--|--|
|JA|Jump if above (if leftOp > rightOp)|
|JNBE|Jump if not below or equal (same as JA)|
|JAE|Jump if above or equal (if leftOp >= rightOp)|
|JNB|Jump if not below (same as JAE)|
|JB|Jump if below (if leftOp < rightOp)|
|JNAE|Jump if not above or equal (same as JB)|
|JBE|Jump if below or equal (if leftOp <= rightOp)|
|JNA|Jump if not above (same as JBE)|

### Jump based on Signed Comparisons

|Mnemonic|Description|
|--|--|
|JG|Jump if greater (if leftOp > rightOp)|
|JNLE|Jump if not less than or equal (same as JG)|
|JGE|Jump if greater than or equal (if leftOp >= rightOp)|
|JNL|Jump if not less (same as JGE)|
|JL|Jump if less (if leftOp < rightOp)|
|JNGE|Jump if not greater than or equal (same as JL)|
|JLE|Jump if less than or equal (if leftOp <= rightOp)|
|JNG|Jump if not greater (same as JLE)|

## Repeat instructions 

- Used for processing multi-byte data (byte arrays)
- Types of Registers
    - ESI register (Source Index Register)
    - EDI register (Destination Index Register)
    - ECX register (Counting Variable register)
- Requires to be properly initialised for instructions to work

![](Repetition%20Instruction%20Termination%20Requirement.png)  

![](Repeat%20Instruction%20Examles.png)  

## The Stack

- Stores memory for functions, local variables and flow control
- `push` items onto stack
- `pop` items off stack
- Has LIFO (Last in First out) structure
- EBP is the base pointer
    - Stays consistent within a given function
    - program can use it as a placeholder
    - keep track of the location of local variables and parameters
- Stack instructions
    - Push
    - Pop
    - Call
    - Leave
    - Enter
    - Ret
- Allocated in a top down format in memory
- Highest Address allocated and used first
- Short term storage only
- frequently stores local
variables, parameters, and the return address
- primary usage is for the management of data exchanged between function calls
- Implementation varies between compilers
- Conventional for local variables and parameters to be reference relative to EBP

![](Stack%20Layout.png)  

![](Stack%20Layout%20Structure.png)  

## Function

- Block of code within a program
- Made to perform a specific task
- Program calls a function and transfer execution flow control to it
- Control is returned to next program instruction after call when function completes execution

### Organisation of Function

Contains
- Prologue
    - Prepare stack and registers for use within the function
- Body
- Epilogue
    - Restores states of stack and registers prior to call
- Prologue and Epilogue can contain buffer overflow protection code

### Function Calls

- Portions of code within a program that perform a specific task and that are relatively independent of the remaining code
-Items associated with each called function are stored in a stack frame
- ESP (Stack Pointer) points to top item
- EBP (Base Pointer) points to start of frame

1. Arguments are placed on the stack using push instructions.
2. A function is called using call memory_location. This causes the current instruction address (that is, the contents of the EIP register) to be pushed onto the stack. This address will be used to return to the main code when the function is finished. When the function begins, EIP is set to memory_location (the start of the function).
3. Through the use of a function prologue, space is allocated on the stack for local variables and EBP (the base pointer) is pushed onto the stack. This is done to save EBP for the calling function.
4. The function performs its work.
5. Through the use of a function epilogue, the stack is restored. ESP is adjusted to free the local variables, and EBP is restored so that the calling function can address its variables properly. The leave instruction can be used as an epilogue because it sets ESP to equal EBP and pops EBP off
the stack.
6. The function returns by calling the ret instruction. This pops the return address off the stack and into EIP, so that the program will continue executing from where the original call was made.
7. The stack is adjusted to remove the arguments that were sent, unless theyâ€™ll be used again later.

### Push Operation

- A 32-bit push operation decrements the stack pointer by 4 and copies a value into the location pointed to by the stack pointer.

![](Pushing%20to%20Stack.png)  

- The Stack grows downwards
- Area below ESP is always available (Unless stack has overflowed)

![](Pushing%20More%20to%20Stack.png)  

- PUSH syntax:
    - PUSH r/m16		
    - PUSH r/m32
    - PUSH imm32


### Pop Operation

- Copies value at stack[ESP] into a register or variable.
- Adds n to ESP, where n is either 2 or 4
    - value of n depends on the attribute of the operand receiving the data

![](Popping%20From%20Stack.png)  

- POP syntax:
    - POP r/m16		
    - POP r/m32

## Basic Constructs

![](Basic%20Constructs.png)  

- Often written in high-level language like C
- Main Method of C Program
![](C%20Program%20Main.png)  
- Parameters argc and argv are determined at runtime
- argc 
    - integer that contains number of arguments on the command line, including the program name
- argv 
    - pointer to an array of strings that contain the command line arguments

![](Recognizing%20main%20method.png)  

![](Recognizing%20main%20method%202.png)  

- .text is the PE file section where the compiler puts the code 
- The first line is a comment, indicated by ; 
- _main is a label, used to reference the address of the main function, 00401150 
- near indicates that the referenced address is in the same section (.text)
- endp - pointer to string pointer array passed to main (in C++)

![](Prologue%20and%20Epilogue.png)  

## Recognising If Else

![](Recognizing%20If%20Else.png)  

## Recognising Loops

![](Recognizing%20Loops.png)  

## Reference Materials
|Reference Material|Page Number|
|--|--|
|[Practical Maware Analysis Book](/Practical%20Malware%20Analysis.pdf)|Page 98 - 118|
